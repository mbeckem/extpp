#ifndef EXTPP_ID_GENERATOR_HPP
#define EXTPP_ID_GENERATOR_HPP

#include <extpp/allocator.hpp>
#include <extpp/assert.hpp>
#include <extpp/btree.hpp>
#include <extpp/engine.hpp>
#include <extpp/identity_key.hpp>

#include <ostream>
#include <type_traits>

#include <fmt/ostream.h>

namespace extpp {

/// Generates unique and reusable IDs.
///
/// IDs are generated by either reusing the lowest free ID
/// or by incrementing an internal counter.
/// Zero is reserved as an "invalid" ID and will not be generated by this class.
/// Negative numbers aren't returned at all.
template<typename T, u32 BlockSize>
class id_generator {
    static_assert(std::is_integral<T>::value,
                  "T must be an integral type.");

private:
    struct interval {
        T begin = 0, end = 0; // Both inclusive.

        interval() = default;

        interval(T begin, T end)
            : begin(begin), end(end)
        {
            EXTPP_ASSERT(begin <= end, "Invalid interval.");
        }

        struct key_extract {
            T operator()(const interval& i) const { return i.end; }
        };
    };

    // Intervals are ordered by their end.
    using tree_type = btree<interval, typename interval::key_extract, std::less<>, BlockSize>;
    using tree_iter = typename tree_type::iterator;
    using tree_cursor = typename tree_type::cursor;

public:
    class anchor {
        /// Contains free intervals (always maximal, i.e. adjacent intervals are merged).
        typename tree_type::anchor tree;

        /// The highest allocated ID.
        T max = 0;

        friend class id_generator;
    };

public:
    id_generator(anchor_ptr<anchor> anc, extpp::engine<BlockSize>& e, extpp::allocator<BlockSize>& a)
        : m_anchor(std::move(anc))
        , m_tree(m_anchor.neighbor(&m_anchor->tree), e, a)
    {}

    extpp::engine<BlockSize>& engine() const { return m_tree.engine(); }
    extpp::allocator<BlockSize>& allocator() const { return m_tree.allocator(); }

    /// Returns the highest allocated ID, which may be zero if no IDs are in use.
    T max() const { return m_anchor->max; }

    /// Returns a new ID.
    /// Call `free(id)` if the ID can be reused.
    T allocate() {
        if (m_tree.empty()) {
            T id = ++m_anchor->max;
            m_anchor.dirty();
            return id;
        }

        return pop_one();
    }

    /// Free an allocated ID. Future allocations will reuse this ID.
    void free(T id) {
        EXTPP_CHECK(id > 0 && id <= max(), "Invalid id.");

        // Highest interval with id < end, i.e. right neighbor to ID.
        tree_cursor right = m_tree.lower_bound(id);
        EXTPP_CHECK(right == m_tree.end() || right->begin > id,
                    "ID has already been freed.");

        // Right neighbor.
        tree_cursor left = right == m_tree.begin() ? m_tree.end() : std::prev(right.iterator());
        EXTPP_CHECK(left == m_tree.end() || left->end < id,
                    "ID has already been freed.");

        EXTPP_ASSERT(left == m_tree.end() || right == m_tree.end() || left->end < right->begin,
                     "Intervals are ordered and do not overlap.");

        // Merge with neighbors if possible.
        interval range(id, id);
        if (left != m_tree.end() && left->end == id - 1) {
            range.begin = left->begin;
            m_tree.erase(left);
        }
        if (right != m_tree.end() && right->begin == id + 1) {
            range.end = right->end;
            m_tree.erase(right);
        }

        // If the range contains the current maximum, then we can remove it altogether.
        if (range.end == m_anchor->max) {
            m_anchor->max = range.begin - 1;
            m_anchor.dirty();
        } else {
            bool inserted;
            std::tie(std::ignore, inserted) = m_tree.insert(range);
            (void) inserted;
            EXTPP_ASSERT(inserted, "Insertion must have taken place.");
        }
    }

    void debug_print(std::ostream& out) {
        fmt::print(out, "Max: {}\n", m_anchor->max);
        fmt::print(out, "\n");

        fmt::print(out, "Free intervals:\n");
        for (const interval& i : m_tree) {
            fmt::print(out, "- [{}, {}]\n", i.begin, i.end);
        }
    }

private:
    T pop_one() {
        EXTPP_ASSERT(!m_tree.empty(), "Tree must not be empty.");
        auto pos = m_tree.begin();

        interval range = *pos;
        T result = range.begin;

        if (pos->begin != pos->end) {
            range.begin += 1;
            m_tree.replace(pos, range);
        } else {
            m_tree.erase(pos);
        }
        return result;
    }

private:
    anchor_ptr<anchor> m_anchor;
    tree_type m_tree;
};

} // namespace extpp

#endif // EXTPP_ID_GENERATOR_HPP

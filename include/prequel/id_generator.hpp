#ifndef PREQUEL_ID_GENERATOR_HPP
#define PREQUEL_ID_GENERATOR_HPP

#include <prequel/allocator.hpp>
#include <prequel/anchor_handle.hpp>
#include <prequel/btree.hpp>
#include <prequel/defs.hpp>
#include <prequel/engine.hpp>

#include <iosfwd>

namespace prequel {

/// Generates unique and reusable IDs.
///
/// IDs are generated by either reusing the lowest free ID
/// or by incrementing an internal counter.
/// Zero is reserved as an "invalid" ID and will not be generated by this class.
class id_generator {
public:
    using value_type = u64;

private:
    struct interval {
        value_type begin = 0, end = 0; // Both inclusive.

        interval() = default;

        interval(value_type begin_, value_type end_)
            : begin(begin_)
            , end(end_) {
            PREQUEL_ASSERT(begin_ <= end_, "Invalid interval.");
        }

        struct key_extract {
            value_type operator()(const interval& i) const { return i.end; }
        };

        static constexpr auto get_binary_format() {
            return binary_format(&interval::begin, &interval::end);
        }
    };

    // Intervals are ordered by their end.
    using interval_tree = btree<interval, interval::key_extract>;
    using interval_cursor = interval_tree::cursor;

public:
    class anchor {
        interval_tree::anchor tree;

        /// The highest allocated ID.
        value_type max = 0;

        static constexpr auto get_binary_format() {
            return binary_format(&anchor::tree, &anchor::max);
        }

        friend class binary_format_access;
        friend class id_generator;
    };

public:
    id_generator(anchor_handle<anchor> _anchor, allocator& _alloc);

    id_generator(id_generator&&) noexcept = default;
    id_generator& operator=(id_generator&&) noexcept = default;

    engine& get_engine() const { return m_tree.get_engine(); }
    allocator& get_allocator() const { return m_tree.get_allocator(); }

    /// Returns the highest allocated ID, which may be zero if no IDs are in use.
    value_type max() const;

    /// Returns a new ID.
    /// Always returns the lowest free id.
    /// Call `free(id)` if the ID can be reused.
    value_type allocate();

    /// Free an allocated ID. Future allocations will reuse this ID.
    void free(value_type id);

    void dump(std::ostream& os) const;

private:
    value_type pop_one();

private:
    anchor_handle<anchor> m_anchor;
    interval_tree m_tree;
};

} // namespace prequel

#endif // PREQUEL_ID_GENERATOR_HPP
